{"entries":[{"timestamp":1746481304704,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":2656,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":814,"diffs":[[1," "]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":78,"length1":271,"diffs":[[1,"        \"device\": \"*\"\n"]]},{"start1":185,"length1":168,"diffs":[[1,"        \"assets.json\"\n"]]},{"start1":214,"length1":75,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"},{"type":"added","filename":"tilemap.g.jres","value":"{\n    \"transparency16\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"tilemapTile\": true\n    },\n    \"*\": {\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"dataEncoding\": \"base64\",\n        \"namespace\": \"myTiles\"\n    }\n}"},{"type":"added","filename":"tilemap.g.ts","value":"// Auto-generated code. Do not edit.\nnamespace myTiles {\n    //% fixedInstance jres blockIdentity=images._tile\n    export const transparency16 = image.ofBuffer(hex``);\n\n    helpers._registerFactory(\"tile\", function(name: string) {\n        switch(helpers.stringTrim(name)) {\n            case \"transparency16\":return transparency16;\n        }\n        return null;\n    })\n\n}\n// Auto-generated code. Do not edit.\n"},{"type":"added","filename":"a-star.ts","value":"//+array+SimpleLocation sim:7.5%, meowbit:10.5% ms comparing with origin\n//% weight=100 color=#0fbc11 icon=\"ïƒƒ\"\nnamespace custom {\n    //costs, scaled up by 1000\n    const NEIGHBOR_COST = 1000;\n    const DIAGONAL_COST = 1414;\n    class PrioritizedLocation {\n        constructor(\n            public loc: SimpleLocation,\n            public cost: number,\n            public totalCost: number  //cost+heuristic\n        ) { }\n    }\n\n    class LocationNode {\n        public visited: boolean;\n\n        constructor(\n            public l: SimpleLocation,\n            public parent: LocationNode,\n            public lastCost: number\n        ) {\n            this.visited = false;\n        }\n    }\n\n    class SimpleLocation {\n        constructor(public col: number, public row: number) { }\n    }\n\n    /**\n     * Find the shortest path between start and end that does not contain walls and optionally limited to a pathable tile.\n     */\n    //% block=\"path from $start to $end||on tiles of $onTilesOf\"\n    //% start.shadow=mapgettile\n    //% end.shadow=mapgettile\n    //% onTilesOf.shadow=tileset_tile_picker\n    //% onTilesOf.decompileIndirectFixedInstances=true\n    //% help=github:arcade-tilemap-a-star/docs/a-star\n    //% group=\"Path Following\" weight=10\n    export function aStar(start: tiles.Location, end: tiles.Location, onTilesOf: Image = null) {\n        const tm = game.currentScene().tileMap;\n        if (!tm || !start || !end)\n            return undefined;\n\n        const end1 = new SimpleLocation(end.col, end.row)\n        const start1 = new SimpleLocation(start.col, start.row)\n        if (!isWalkable(end1, onTilesOf, tm))\n            return undefined;\n\n        return generalAStar(tm, start1, onTilesOf,\n            t => tileLocationHeuristic(t, end1),\n            l => l.col == end1.col && l.row == end1.row);\n    }\n\n    export function aStarToAnyOfType(start: tiles.Location, tile: Image, onTilesOf: Image) {\n        const tm = game.currentScene().tileMap;\n        if (!tm || !start)\n            return undefined;\n        const start1 = new SimpleLocation(start.col, start.row)\n        const endIndex = tm.getImageType(tile);\n        const potentialEndPoints = tm.getTilesByType(endIndex);\n\n        if (!potentialEndPoints || potentialEndPoints.length === 0)\n            return undefined;\n\n        return generalAStar(tm, start1, onTilesOf,\n            t => 0,\n            l => {\n                return endIndex === tm.getTileIndex((l as any)._col, (l as any)._row)\n            });\n    }\n\n    export function generalAStar(tm: tiles.TileMap, start: SimpleLocation, onTilesOf: Image,\n        heuristic: (tile: SimpleLocation) => number,\n        isEnd: (tile: SimpleLocation) => boolean): tiles.Location[] {\n\n        if (!isWalkable(start, onTilesOf, tm)) {\n            return undefined;\n        }\n\n        const consideredTiles: Array<PrioritizedLocation> = []\n        const encountedLocations: LocationNode[][] = [[]];\n\n        function updateOrFillLocation(l: SimpleLocation, parent: LocationNode, cost: number) {\n            const row = l.row;\n            const col = l.col;\n\n\n            const colData = (encountedLocations[col] || (encountedLocations[col] = []));\n            const lData = colData[row];\n\n            if (!lData) {\n                colData[row] = new LocationNode(\n                    l,\n                    parent,\n                    cost\n                );\n            } else if (lData.lastCost > cost) {\n                lData.lastCost = cost;\n                lData.parent = parent;\n            } else {\n                return;\n            }\n\n            const newConsideredTile = new PrioritizedLocation(\n                l,\n                cost,\n                cost + heuristic(l)\n            )\n\n\n            if (consideredTiles.length == 0) {\n                consideredTiles.push(newConsideredTile)\n                return\n            }\n            let i = consideredTiles.length - 1\n            for (; i >= 0; i--) {  // seek & insert from end, last N are more possible hit\n                if (newConsideredTile.totalCost < consideredTiles[i].totalCost) {\n                    consideredTiles.insertAt(i + 1, newConsideredTile)\n                    return;\n                }\n            }\n            if (i < 0)\n                consideredTiles.insertAt(0, newConsideredTile)\n        }\n\n        updateOrFillLocation(start, null, 0);\n\n        let end: SimpleLocation = null;\n        while (consideredTiles.length !== 0) {\n\n            const currLocation = consideredTiles.pop();\n\n            if (isEnd(currLocation.loc)) {\n                end = currLocation.loc;\n                break;\n            }\n\n            const row = currLocation.loc.row;\n            const col = currLocation.loc.col;\n\n\n            const dataForCurrLocation = encountedLocations[col][row];\n\n            if (dataForCurrLocation && dataForCurrLocation.visited) {\n                continue;\n            }\n            dataForCurrLocation.visited = true;\n\n            const left = new SimpleLocation(col - 1, row);\n            const right = new SimpleLocation(col + 1, row);\n            const top = new SimpleLocation(col, row - 1);\n            const bottom = new SimpleLocation(col, row + 1);\n\n            let leftIsWall = false\n            let rightIsWall = false\n            let topIsWall = false\n            let bottomIsWall = false\n\n            if (onTilesOf) {\n                leftIsWall = !isWalkable(left, onTilesOf, tm);\n                rightIsWall = !isWalkable(right, onTilesOf, tm);\n                topIsWall = !isWalkable(top, onTilesOf, tm);\n                bottomIsWall = !isWalkable(bottom, onTilesOf, tm);\n            } else {\n                leftIsWall = tm.isObstacle(left.col, left.row);\n                rightIsWall = tm.isObstacle(right.col, right.row);\n                topIsWall = tm.isObstacle(top.col, top.row);\n                bottomIsWall = tm.isObstacle(bottom.col, bottom.row);\n            }\n\n\n            const neighborCost = currLocation.cost + NEIGHBOR_COST;\n            const cornerCost = currLocation.cost + DIAGONAL_COST;\n\n            if (!leftIsWall) {\n                updateOrFillLocation(left, dataForCurrLocation, neighborCost);\n                if (!topIsWall) {\n                    const topLeft = new SimpleLocation(col - 1, row - 1);\n                    if (!tm.isObstacle(topLeft.col, topLeft.row)) updateOrFillLocation(topLeft, dataForCurrLocation, cornerCost);\n                }\n                if (!bottomIsWall) {\n                    const bottomLeft = new SimpleLocation(col - 1, row + 1);\n                    if (!tm.isObstacle(bottomLeft.col, bottomLeft.row)) updateOrFillLocation(bottomLeft, dataForCurrLocation, cornerCost);\n                }\n            }\n\n            if (!rightIsWall) {\n                updateOrFillLocation(right, dataForCurrLocation, neighborCost);\n                if (!topIsWall) {\n                    const topRight = new SimpleLocation(col + 1, row - 1);\n                    if (!tm.isObstacle(topRight.col, topRight.row)) updateOrFillLocation(topRight, dataForCurrLocation, cornerCost);\n                }\n                if (!bottomIsWall) {\n                    const bottomRight = new SimpleLocation(col + 1, row + 1);\n                    if (!tm.isObstacle(bottomRight.col, bottomRight.row)) updateOrFillLocation(bottomRight, dataForCurrLocation, cornerCost);\n                }\n            }\n\n            if (!topIsWall) updateOrFillLocation(top, dataForCurrLocation, neighborCost);\n            if (!bottomIsWall) updateOrFillLocation(bottom, dataForCurrLocation, neighborCost);\n        }\n\n        const endCol = end && encountedLocations[end.col];\n        const endDataNode = endCol && endCol[end.row];\n\n        // no path found\n        if (!end || !endDataNode)\n            return undefined;\n\n        let curr = endDataNode;\n\n        // otherwise trace back path to end\n        const output: tiles.Location[] = [];\n\n        while (curr) {\n            output.unshift(new tiles.Location(curr.l.col, curr.l.row, tm));\n            curr = curr.parent;\n        }\n\n        return output;\n    }\n\n    function tileLocationHeuristic(tile: SimpleLocation, target: SimpleLocation) {\n        const xDist = Math.abs(target.col - tile.col)\n        const yDist = Math.abs(target.row - tile.row)\n        return Math.max(xDist, yDist) * NEIGHBOR_COST + Math.min(xDist, yDist) *\n            (DIAGONAL_COST - NEIGHBOR_COST)\n    }\n\n    function isWalkable(loc: SimpleLocation, onTilesOf: Image, tm: tiles.TileMap): boolean {\n        if (tm.isObstacle(loc.col, loc.row)) return false;\n        if (!onTilesOf) return true;\n        const img = tm.getTileImage(tm.getTileIndex(loc.col, loc.row))\n        return img.equals(onTilesOf);\n    }\n\n    //%block=\"can $sprite=variables_get(sprite) see $target=variables_get(otherSprite) in range $range â‰ˆ direction $sightDirection degrees, $sightRange degrees\"\n    //%blockid=spritesightisinsightcone\n    //% inlineInputMode=inline\n    //%group='Computer Vision'\n    export function isInSightCone(sprite: Sprite, target: Sprite, range: number, sightDirection: number, sightRange: number) {\n        if (!sight.distanceInRange(sprite, target, range)) {\n            return false\n        }\n\n        if (sight.isWallBetween(sprite, target)) {\n            return false\n        }\n\n        let angle = Math.atan2(target.y - sprite.y, target.x - sprite.x)\n\n        angle = ((angle / Math.PI * 180) + 360) % 360\n        sightDirection = (sightDirection + 360) % 360\n        return Math.abs(angle - sightDirection) < sightRange\n    }\n\n    //%block=\"can $sprite=variables_get(sprite) see $target=variables_get(otherSprite) in circular range %range\"\n    //%blockid=spritesightisinsight \n    //%group='Computer Vision'\n    export function isInSight(sprite: Sprite, target: Sprite, range: number) {\n        if (!sight.distanceInRange(sprite, target, range)) {\n            return false\n        }\n\n        return !sight.isWallBetween(sprite, target)\n    }\n}"},{"type":"added","filename":"path-following.ts","value":"//% weight=100 color=#0fbc11 icon=\"ïƒƒ\"\nnamespace custom {\n    const PATH_FOLLOW_KEY = \"A_STAR_PATH_FOLLOW\";\n    const PATH_COMPLETION_KEY = \"A_STAR_PATH_COMPLETION_HANDLER\";\n\n    class PathFollowingSprite {\n        public index: number;\n        public onEndHandler: () => void;\n\n        constructor(\n            public sprite: Sprite,\n            public path: tiles.Location[],\n            public speed: number\n        ) {\n            this.index = 0;\n        }\n    }\n\n    class PathCompletionEvent {\n        constructor(\n            public kind: number,\n            public handler: (sprite: Sprite, location: tiles.Location) => void\n        ) { }\n    }\n\n    function init() {\n        if (!game.currentScene().data[PATH_FOLLOW_KEY]) {\n            game.currentScene().data[PATH_FOLLOW_KEY] = [] as PathFollowingSprite[];\n            game.currentScene().data[PATH_COMPLETION_KEY] = [] as PathCompletionEvent[];\n\n            game.onUpdate(function () {\n                const store = getPathFollowingSprites();\n                const handlers = getPathCompletionEvents();\n\n                for (let i = store.length - 1; i >= 0; i--)\n                // note we enumerate from the end so we can safely remove and push without changing\n                // the worklist\n                {\n                    const pfs = store[i]\n                    const { sprite, index, path, speed } = pfs;\n                    const target: tiles.Location = path[index];\n\n                    const { x, y, vx, vy } = sprite;\n\n                    const pastTargetHorizontally = !vx || (vx < 0 && x <= target.x) || (vx > 0 && x >= target.x);\n                    const pastTargetVertically = !vy || (vy < 0 && y <= target.y) || (vy > 0 && y >= target.y);\n\n                    if (pastTargetHorizontally && pastTargetVertically) {\n                        // target next index\n                        pfs.index++;\n                        const newTarget = path[pfs.index];\n                        if (!newTarget) {\n                            sprite.setVelocity(0, 0);\n                            target.place(sprite);\n                            store.removeAt(i);\n                            // explicit endCb overrides kind cb\n                            if (pfs.onEndHandler) {\n                                pfs.onEndHandler();\n                            } else {\n                                handlers.forEach(completionHandler => {\n                                    if (completionHandler.kind === sprite.kind()) {\n                                        completionHandler.handler(sprite, path[pfs.index - 1]);\n                                    }\n                                });\n                            }\n                        } else {\n                            target.place(sprite);\n                            setVelocityTowards(sprite, newTarget, speed);\n                        }\n                    }\n                }\n            });\n        }\n    }\n\n    function setVelocityTowards(sprite: Sprite, target: tiles.Location, speed: number) {\n        const dx = target.x - sprite.x;\n        const dy = target.y - sprite.y;\n        const dist = Math.sqrt(dx * dx + dy * dy) || 1;\n        sprite.vx = (dx / dist) * speed;\n        sprite.vy = (dy / dist) * speed;\n    }\n\n    // TODO: probably should have logic to bail when a tile that wasn't a wall\n    //      is set to be a wall. Or just use velocity, and let enemy run into wall\n\n    /**\n     * Give a sprite a path to follow\n     * @param sprite sprite to give a path to\n     * @param path path to follow\n     * @param speed speed at which to follow path eg: 50\n     */\n    //% block=\"sprite $sprite follow path $path || speed %speed\"\n    //% sprite.shadow=\"variables_get\"\n    //% sprite.defl=\"mySprite\"\n    //% path.shadow=\"variables_get\"\n    //% path.defl=\"locationTiles\"\n    //% help=github:arcade-tilemap-a-star/docs/follow-path\n    //% group=\"Path Following\" weight=9\n    export function followPath(sprite: Sprite, path: tiles.Location[], speed: number = 50) {\n        if (!sprite)\n            return;\n        if (!path || !path.length || !speed) {\n            const pathFollowingSprites = getPathFollowingSprites();\n            if (pathFollowingSprites) {\n                for (let i = pathFollowingSprites.length - 1; i >= 0; i--) {\n                    const pfs = pathFollowingSprites[i];\n                    if (pfs.sprite === sprite) {\n                        sprite.vx = 0;\n                        sprite.vy = 0;\n                        pathFollowingSprites.removeAt(i);\n                    }\n                }\n            }\n            return;\n        }\n\n        const tm = game.currentScene().tileMap;\n        if (!tm)\n            return;\n\n        // are we in a wall?\n        if (tm.isOnWall(sprite)) {\n            // if so, find the closest path tile by distance and teleport there\n            let nearestTile = path[0]\n            let minDistSquared = 999999;\n            for (let p of path) {\n                const distSqrd = (p.x - sprite.x) ** 2 + (p.y - sprite.y) ** 2\n                if (distSqrd < minDistSquared) {\n                    nearestTile = p\n                    minDistSquared = distSqrd\n                }\n            }\n            nearestTile.place(sprite);\n            const remainingPath = getRemainingPath(sprite, path);\n            _followPath(sprite, remainingPath, speed);\n            return\n        }\n\n        // if we're on the path already, just follow the subset of the remaining path\n        const remainingPath = getRemainingPath(sprite, path);\n        if (remainingPath) {\n            _followPath(sprite, remainingPath, speed);\n            return;\n        }\n\n        // otherwise, path with a-star (no heuristic and no onTileOf) to the path\n        const currentLocation = locationOfSprite(sprite)\n        const pathToNearest = generalAStar(tm, currentLocation, null, () => 0, tile => {\n            for (let pathTile of path) {\n                if (tile.col === pathTile.col && tile.row === pathTile.row) {\n                    return true;\n                }\n            }\n            return false;\n        });\n\n        _followPath(sprite, pathToNearest, speed, () => {\n            // then follow the remaining of the path\n            const remainingPath = getRemainingPath(sprite, path);\n            _followPath(sprite, remainingPath, speed);\n        })\n    }\n\n    /**\n     * Returns true if the sprite is currently following a path,\n     * and false otherwise\n     * @param sprite sprite to check if following path\n     */\n    //% block=\"sprite $sprite is following a path\"\n    //% sprite.shadow=\"variables_get\"\n    //% sprite.defl=\"mySprite\"\n    //% help=github:arcade-tilemap-a-star/docs/sprite-is-following-path\n    //% group=\"Path Following\" weight=8\n    export function spriteIsFollowingPath(sprite: Sprite): boolean {\n        init();\n        return getPathFollowingSprites().some(pfs => pfs.sprite === sprite);\n    }\n\n    /**\n     * Returns an approximation between 0 and 100 of how much of the\n     * percentage of the path that the given sprite is following has completed.\n     * If the sprite is not currently following a path,\n     * this returns 100 (as the sprite has trivially completed the empty path).\n     */\n    //% block=\"percent sprite $sprite path completion\"\n    //% sprite.shadow=\"variables_get\"\n    //% sprite.defl=\"mySprite\"\n    //% help=github:arcade-tilemap-a-star/docs/sprite-percent-path-completed\n    //% group=\"Path Following\" weight=7\n    export function spritePercentPathCompleted(sprite: Sprite): number {\n        init();\n        const pfs = getPathFollowingSprites().find(pfs => pfs.sprite === sprite);\n        // TODO: is this behavior useful, or should this return 0 or undefined?\n        if (!pfs)\n            return 100;\n        return 100 - (100 * (pfs.path.length - pfs.index) / pfs.path.length);\n    }\n\n    /**\n     * Event handler for when a sprite of the given kind completes a path\n     */\n    //% weight=100 draggableParameters=\"reporter\"\n    //% block=\"on $sprite of kind $kind completes path at $location\"\n    //% kind.shadow=spritekind\n    //% help=github:arcade-tilemap-a-star/docs/on-path-completion\n    //% group=\"Path Following\" weight=6\n    export function onPathCompletion(\n        kind: number,\n        handler: (sprite: Sprite, location: tiles.Location) => void\n    ) {\n        init();\n        if (kind == null || !handler)\n            return;\n        getPathCompletionEvents().push(\n            new PathCompletionEvent(kind, handler)\n        );\n    }\n\n    export function teleportToAndFollowPath(sprite: Sprite, path: tiles.Location[], speed?: number) {\n        _followPath(sprite, path, speed);\n    }\n\n    export function _followPath(sprite: Sprite, path: tiles.Location[], speed?: number, endCb?: () => void) {\n        if (!sprite)\n            return;\n\n        init();\n        const store = getPathFollowingSprites();\n        const previousEl = store.find(el => el.sprite === sprite);\n\n        const start = path && path[0];\n        if (!start) {\n            if (previousEl) {\n                store.removeElement(previousEl);\n            }\n            return;\n        }\n\n        const pfs = previousEl || new PathFollowingSprite(\n            sprite,\n            path,\n            speed || 50\n        );\n        if (previousEl) {\n            if (speed)\n                previousEl.speed = speed;\n            previousEl.path = path;\n            previousEl.index = 0;\n\n            if (endCb) {\n                previousEl.onEndHandler = endCb;\n            }\n        } else {\n            pfs.onEndHandler = endCb;\n            store.push(pfs);\n        }\n\n        setVelocityTowards(sprite, start, pfs.speed)\n    }\n\n    /**\n     * Returns the index in the path which is closest to the current sprite by direct distance\n     */\n    export function getNearestPathIdx(sprite: Sprite, path: tiles.Location[]): number {\n        let minDistSqrd = 99999\n        let idx = 0;\n        for (let i = 0; i < path.length; i++) {\n            let t = path[i];\n            let distSqrd = (sprite.x - t.x) ** 2 + (sprite.y - t.y) ** 2;\n            if (distSqrd < minDistSqrd) {\n                minDistSqrd = distSqrd;\n                idx = i;\n            }\n        }\n        return idx\n    }\n\n    function getPathFollowingSprites(): PathFollowingSprite[] {\n        return game.currentScene().data[PATH_FOLLOW_KEY] as PathFollowingSprite[];\n    }\n\n    function getPathCompletionEvents(): PathCompletionEvent[] {\n        return game.currentScene().data[PATH_COMPLETION_KEY] as PathCompletionEvent[];\n    }\n\n    function screenCoordinateToTile(value: number) {\n        const tm = game.currentScene().tileMap;\n        if (!tm) return value >> 4;\n        return value >> tm.scale;\n    }\n\n    function locationOfSprite(s: Sprite): tiles.Location {\n        return tiles.getTileLocation(screenCoordinateToTile(s.x), screenCoordinateToTile(s.y));\n    }\n\n    function getRemainingPath(sprite: Sprite, path: tiles.Location[]): tiles.Location[] | null {\n        const currentLocation = locationOfSprite(sprite)\n        for (let i = 0; i < path.length; i++) {\n            const pathTile = path[i];\n            if (currentLocation.x === pathTile.x && currentLocation.y === pathTile.y) {\n                const remainingPath = i === 0 ? path : path.filter((_, j) => j >= i);\n                return remainingPath;\n            }\n        }\n        return null\n    }\n}"},{"type":"added","filename":"sight.ts","value":"namespace sight {\n\n\n    let showTestingTiles = false\n\n    export function distanceInRange(sprite: Sprite, target: Sprite, range: number) {\n        return Math.sqrt(Math.pow(sprite.x - target.x, 2) + Math.pow(sprite.y - target.y, 2)) <= range\n    }\n\n    export function currentScale() {\n        return game.currentScene().tileMap.scale\n    }\n\n    export function scaleDelta() {\n        return 1 << currentScale()\n    }\n\n    const SPRITE_KIND_TESTING = SpriteKind.create()\n\n    export function placeTestSprite(col: number, row: number, h: Image) {\n        if (showTestingTiles) {\n            let testSprite = sprites.create(h, SPRITE_KIND_TESTING)\n            tiles.placeOnTile(testSprite, tiles.getTileLocation(col, row))\n        }\n    }\n\n\n    export function isWallBetween(start: Sprite, end: Sprite) {\n        if (showTestingTiles) {\n            for (let sprite of sprites.allOfKind(SPRITE_KIND_TESTING)) {\n                sprite.destroy()\n            }\n        }\n\n        // always from left to right\n        if (start.x > end.x) {\n            let temp = start\n            start = end\n            end = temp\n        }\n\n        let slope = (end.y - start.y) / (end.x - start.x)\n        let ySign = (end.y > start.y) ? 1 : -1\n\n        // points at column boundaries\n        let boundaryPoints = []\n        for (let x = start.x + scaleDelta() - start.x % scaleDelta(), y = start.y + (scaleDelta() - start.x % scaleDelta()) * slope; x < end.x; x += scaleDelta(), y += scaleDelta() * slope) {\n            boundaryPoints.push([x, y])\n        }\n\n        // for each points on vertical lines, check if tile to the right isObstacle\n        for (let boundaryPoint of boundaryPoints) {\n            let [col, row] = [boundaryPoint[0] >> currentScale(), boundaryPoint[1] >> currentScale()]\n            placeTestSprite(col, row, img`\n                c c c c c c c c c c c c c c c c\n                c c c c c c c c c c c c c c c c\n                c c c c c c c c c c c c c c c c\n                c c c c c c c c c c c c c c c c\n                c c c c c c c c c c c c c c c c\n                c c c c c c c c c c c c c c c c\n                c c c c c c c c c c c c c c c c\n                c c c c c c c c c c c c c c c c\n                c c c c c c c c c c c c c c c c\n                c c c c c c c c c c c c c c c c\n                c c c c c c c c c c c c c c c c\n                c c c c c c c c c c c c c c c c\n                c c c c c c c c c c c c c c c c\n                c c c c c c c c c c c c c c c c\n                c c c c c c c c c c c c c c c c\n                c c c c c c c c c c c c c c c c\n            `)\n            if (game.currentScene().tileMap.isObstacle(col, row)) {\n                return true\n            }\n        }\n\n        boundaryPoints = []\n\n        if (ySign > 0) {\n            let x = start.x + (scaleDelta() - (start.y % scaleDelta())) / slope\n            let y = start.y - (start.y % scaleDelta()) + scaleDelta()\n\n            while ((y < end.y)) {\n                boundaryPoints.push([x, y])\n                y += scaleDelta(),\n                    x += scaleDelta() / slope\n            }\n\n        } else {\n            let x = start.x - (start.y % scaleDelta()) / slope\n            let y = start.y - (start.y % scaleDelta())\n\n            while ((y > end.y)) {\n                boundaryPoints.push([x, y])\n                y -= scaleDelta(),\n                    x -= scaleDelta() / slope\n            }\n\n        }\n\n        // for each points on horizontal lines, check if tile to the up/down (sign) isObstacle\n        for (let boundaryPoint of boundaryPoints) {\n            let [col, row] = [boundaryPoint[0] >> currentScale(), (boundaryPoint[1] >> currentScale()) + (ySign > 0 ? 0 : -1)]\n            placeTestSprite(col, row, img`\n                2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\n                2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\n                2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\n                2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\n                2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\n                2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\n                2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\n                2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\n                2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\n                2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\n                2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\n                2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\n                2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\n                2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\n                2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\n                2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\n            `)\n            if (game.currentScene().tileMap.isObstacle(col, row)) {\n                return true\n            }\n        }\n\n        return false\n    }\n\n    export function toggleTestingTiles(on: boolean) {\n        showTestingTiles = on\n    }\n\n    export function isPointInRange(x: number, y: number,\n        angle_lower_in_360: number, angle_upper_in_360: number): boolean {\n        let angle = Math.atan2(y, x) / Math.PI * 180\n        let pointAngleIn360 = (angle + 360) % 360\n        console.log(pointAngleIn360)\n        return pointAngleIn360 >= angle_lower_in_360 && pointAngleIn360 <= angle_upper_in_360\n    }\n\n    export function isInRange(x: number, y: number,\n        sightDirection: number, sightRange: number) {\n        let angle = Math.atan2(y, x) / Math.PI * 180\n        let pointAngleIn360 = (angle + 360) % 360\n        let result = Math.abs(sightDirection - pointAngleIn360) <= sightRange\n        return result\n    }\n}"},{"type":"added","filename":"sight_range.ts","value":"namespace sight {\n\n    const ALERT_RANGE_SPRITE_DATA_KEY = \"ALERT_RANGE_SPRITE_DATA_KEY\"\n    const ALERT_RANGE_SPRITES_SCENE_DATA_KEY = \"ALERT_RANGE_SPRITES_SCENE_DATA_KEY\"\n\n    export class SightRangeSprite extends Sprite {\n        protected shaderSprite: Sprite\n        protected target: Sprite\n        protected range: number\n\n        public constructor(target: Sprite, shaderSprite: Sprite, range: number) {\n            super(img`.`)\n            this.target = target\n            this.range = range\n            this.shaderSprite = shaderSprite\n        }\n\n        updatePosition() {\n            this.shaderSprite.x = this.target.x\n            this.shaderSprite.y = this.target.y\n        }\n\n        destroy(effect?: effects.ParticleEffect, duration?: number) {\n            super.destroy()\n            this.shaderSprite.destroy()\n        }\n    }\n\n    export class CircularSightRangeSprite extends SightRangeSprite {\n\n        public constructor(target: Sprite, shaderSprite: Sprite, range: number) {\n            super(target, shaderSprite, range)\n            game.currentScene().physicsEngine.addSprite(this)\n            this.target.onDestroyed(() => {\n                this.shaderSprite.destroy()\n                this.destroy()\n            })\n        }\n    }\n\n    export class ConicalSightRangeSprite extends SightRangeSprite {\n\n        private direction: number\n        private sightRange: number\n\n        public constructor(target: Sprite, shaderSprite: Sprite, range: number, direction: number, sightRange: number) {\n            super(target, shaderSprite, range)\n\n            this.direction = direction\n            this.sightRange = sightRange\n        }\n\n        updateDirection(direction: number) {\n            this.direction = direction\n            this.shaderSprite.destroy()\n\n            this.shaderSprite = createSectionShader(this.range, this.direction, this.sightRange)\n        }\n    }\n\n    export function updateSightDirection(target: SightRangeSprite, sightDirection: number) {\n        if (target instanceof ConicalSightRangeSprite) {\n            let sightRangeSprite = target as ConicalSightRangeSprite\n            sightRangeSprite.updateDirection(sightDirection)\n        }\n    }\n\n    export function sightRangeSpriteOn(sprite: Sprite): SightRangeSprite {\n        return sprites.readDataSprite(sprite, ALERT_RANGE_SPRITE_DATA_KEY) as SightRangeSprite\n    }\n\n    export function createSectorAlertRange(target: Sprite, range: number, sightDirection: number, sightRange: number): ConicalSightRangeSprite {\n        let shaderSprite = createSectionShader(range, sightDirection, sightRange / 2)\n        let result = new ConicalSightRangeSprite(target, shaderSprite, range, sightDirection, sightRange / 2)\n\n        sprites.setDataSprite(target, ALERT_RANGE_SPRITE_DATA_KEY, result)\n\n        registerSightRangeSprite(result)\n\n        return result;\n    }\n\n    function registerSightRangeSprite(sightRangeSprite: SightRangeSprite) {\n        let alertRangeSprites = game.currentScene().data[ALERT_RANGE_SPRITES_SCENE_DATA_KEY] as SightRangeSprite[]\n        if (!alertRangeSprites) {\n            game.currentScene().data[ALERT_RANGE_SPRITES_SCENE_DATA_KEY] = alertRangeSprites = [] as SightRangeSprite[]\n            game.eventContext().registerFrameHandler(scene.UPDATE_PRIORITY + 10, () => {\n                let alertRangeSprites = game.currentScene().data[ALERT_RANGE_SPRITES_SCENE_DATA_KEY] as SightRangeSprite[]\n                for (let alertRangeSprite of alertRangeSprites) {\n                    alertRangeSprite.updatePosition()\n                }\n            })\n        }\n        alertRangeSprites.push(sightRangeSprite)\n    }\n\n    export function createCirularAlertRange(target: Sprite, range: number): CircularSightRangeSprite {\n        let shaderSprite = createCircularShaderSprite(range)\n        let result = new CircularSightRangeSprite(target, shaderSprite, range)\n        sprites.setDataSprite(target, ALERT_RANGE_SPRITE_DATA_KEY, result)\n\n        registerSightRangeSprite(result)\n\n        return result;\n    }\n\n    function createCircularShaderSprite(range: number) {\n        let result = image.create(range * 2, range * 2)\n        result.fillCircle(range, range, range, 2)\n        return shader.createImageShaderSprite(result, shader.ShadeLevel.One)\n    }\n\n    function createSectionShader(range: number, sightDirection: number, sightRange: number): Sprite {\n        let result = image.create(range * 2, range * 2)\n        for (let degree = sightDirection - sightRange; degree <= sightDirection + sightRange; degree++) {\n            let degreeIn360 = (degree + 360) % 360\n            let x = range * Math.cos(degreeIn360 / 180 * Math.PI)\n            let y = Math.sqrt(range * range - x * x)\n            if (degreeIn360 <= 180) {\n                y = -y\n            }\n            result.drawLine(range, range, range + x, range - y, 2)\n        }\n        return shader.createImageShaderSprite(result, shader.ShadeLevel.One)\n    }\n}"}]}],"snapshots":[{"timestamp":1746481304703,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>","main.ts":" ","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"Final Extension\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}}],"shares":[],"lastSaveTime":1746481486885}